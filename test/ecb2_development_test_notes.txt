ECB2 Development Testing
========================

1. Install the module

2. Create 'ECB2 Test' page:
    - Create a new Page Template 'ECB2_Test' that only contains:
        {include file='module_file_tpl:ECB2;ECB2_Test_Template.tpl'}
    - Create 'ECB2 Test' page, using the above template.  

3. Create 'ecb2_test_udt_options' UDT:
    - create a new UDT called 'ecb2_test_udt_options', copy in contents from:
        '/test/ecb2_test_udt_options.php'


4. Create template 'ECB2_test_template_options' in Design Manager:
    - copy in contents from: '/test/ECB2_test_template_options.tpl'


5. Create a summary template 'item_dropdown' in a LISE Instance e.g. LISEProjects 
    - copy in contents from '/test/ECB2_test_LISE_template.tpl'

    
6. Create a CustomGS field called 'Section Styles' and add in the following:
"
Width 100% (default)=width-100
Width 83%=width-83
Width 66%=width-66
Width 50%=width-50
Full page width=width-full
Content centred (default)=content-centered
Content left=content-left
Content right=content-right
Background grey=background-grey text-white
Background white=background-white
Background image=background-image
Overlap above=overlap-above
Overlap below=overlap-below
Clickable=clickable
"


Updating Icon font
==================
- use selection json file in /lib/css to open font selection in icomoon
- add any new fonts - free / open source only
- download selection and save 
- upload all font files & new selection json file into /lib/css
- update /lib/css/ecb2_admin.css from latest icomoon css file


Storing additional content
==========================
This was a key decision for the development of v2. Initial plan was to use separate database, but also simply storing all in json format in a single field very attractive option (as per Velden's FCB module). Key issues are:
    - search indexing of data - is necessary - this might be automatically done even if data in json format in content_props. If not then would need additional indexing code - still possible when in json format!
    - adding & copying pages - would be automatic is data stored in content_props (json format). Problomatic if stored in seperate database. 'content_id' is not allocated until after the content block processing occurs (e.g. in ECB2). So instead the content_prop value would need to hold a reference to the id in ECB2 (a change but doable)
    - also json_decode is likely to be faster in frontend actions than manually building a multi-level object from one or more data queries
    - See: What are the pros and cons of NoSQL and RDBMS? Looks like NoSQL (e.g. json) would be better suited to requirements
    - development also probably faster & simpler
    - define robust data structure

Decision: change to using json format (instead of separate database). Other modules could also use ECB2 field types if they followed the same process and use the XL database field type


define a format for extend data that is flexible enough that it does not need to change in the future:

- see ecb2_FieldDefBase -> create_field_object() for notes in comments

- output is a field object (stdObject)
        each object has:
            - either (depending on 'type'):
                values - an array of sorted values
                or
                sub_fields - an array of field objects
            - extra (params - need to try this to define) - not yet used


textinput e.g. test1c ... either just a single value (OLD style)



Convert into sub_field supported class
======================================
class file
==========

1. add label into default parameters
            'label'         => ['default' => '',    'filter' => FILTER_SANITIZE_STRING],

2. check options / default_parameters, for anything not suitable for Group sub_field


3. add label & sub_....'s   into  get_content_block_input()
        $class = '';    // check if it's already created / assigned
        $tpl->assign( 'label', $this->options['label'] );
        $tpl->assign( 'is_sub_field', $this->is_sub_field );
        if ( $this->is_sub_field ) {
            $tpl->assign( 'sub_row_number', $this->sub_row_number );
            $tpl->assign( 'subFieldName', $this->sub_parent_block.'[r_'.$this->sub_row_number.']['.
                $this->block_name.']' );
            $tpl->assign( 'subFieldId', $this->sub_parent_block.'_r_'.$this->sub_row_number.'_'.
                $this->block_name );
            $class .= ' repeater-field';
        }
        $tpl->assign('class', $class);  
        


.tpl file 
=========

4. Modify temple to output sub_fields, see: input.ecb2fd_textinput.tpl (as sample)
    {if $is_sub_field}
        ... and a version of the input ... 
        ... 
        ... 



Type of output data
===================
textinput       - string / strings '||' delimited if older style repeater / json array if repeater 
                    (or was previously repeater - not really necessary!) or assign used
textarea        - string - json array if repeater (or was previously repeater)
dropdown        - string (single select) / string comma separated (multiple select) / 
                    ??? json array if multiple ???
group           - json object
gallery         - json object
sortablelist    - string comma separated
checkbox        - 0 or 1
radio           - string
color_picker    - string
date_time_picker - string
file_selector   - string
page_picker     - string
gallery_picker  - string
module_picker   - string
hidden          - string